 In the first target we have a buffer overflow vulnerability. The program allow us to provide a character pointer(argv[1]) that have it content copied into a buffer of size 240(buf[240])  through the function "strcpy" (in bar). The problem is that function strcpy(dest, src) just copy all content of src into dest until it find a  NUL character ( 0\'), it means that the size of src is never checked, and  if its greater than the dest size (240 in our example), it overwrites adjacent memory.
Knowing this vulnerability and using our understanding of the memory stack, we want to overwrite the return address on the function 'foo' with the address of our buffer which contains the shell code (machine code that will execute the shell). The returning address is located 8 bytes  below buffer on the stack ( Stack = buffer[240] | EBP[4] | EIP[4] ). 
In my attack, I created a buffer of size 248 and filled it with NOP's (0x90), after that I put the shellcode in the middle of my stack (No specific reason for this) and the buffer address (0xbffffc88) in the end of the stack. So, the return address will be overwritten with the buffer address and execute the shell code after pass through the NOP's.
I figure out this return address through GDB. First, I set a breakpoint on line 15 (b 15) and then a printed the address of buf (p &buf).

